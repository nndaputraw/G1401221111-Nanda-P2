---
title: "Project Week 2"
author: "Ananda Putra Wijaya/G1401221111"
date: "2024-08-30"
output:
  pdf_document: default
  html_document: default
---

# Inisiasi *library*

```{r}
library(dplyr)
library(TTR)
library(forecast)
library(lmtest) 
library(orcutt) 
library(HoRM) 
library(readxl)
```

# Inisiasi data

```{r}
DataW2<-as.data.frame(read_xlsx("C:/Tugas/Semester 5/Metode Peramalan Deret Waktu/Minggu 2/Data Project Week 2.xlsx"))
DataW2$Tahun <- as.numeric(DataW2$Tahun)

DataW2
Tahun<-as.numeric(DataW2$Tahun)
PDB<-DataW2$PDB
```
Data yang digunakan adalah data nilai PDB negara Bermuda dalam rentang tahun 1960-2022(full)

# Transformasi data PDB menjadi *time series*

```{r}
DataW2ts<-ts(DataW2$PDB)
DataW2ts
```

# *Plot* awal data PDB

```{r}
ts.plot(DataW2ts, xlab="Periode Waktu", ylab="PDB", main= "Plot Deret Waktu PDB Bermuda")
points(DataW2ts)
```

# Peramalan menggunakan DMA

```{r}
datasma <- SMA(DataW2ts, n=3)
dma <- SMA(datasma, n = 3)
At <- 2*datasma - dma
Bt <- 2/(3-1)*(datasma - dma)
datadma<- At+Bt
dmaramal<- c(NA, datadma)

t = 1:5
f = c()

for (i in t) {
  f[i] = At[length(At)] + Bt[length(Bt)]*(i)
}
```

## *Plot* DMA

```{r}
datagab <- cbind(
  aktual = c(DataW2ts, rep(NA, 5)), 
  pemulusan1 = c(datasma, rep(NA, 5)),
  pemulusan2 = c(datadma, rep(NA, 5)),
  At = c(At, rep(NA, 5)), 
  Bt = c(Bt, rep(NA, 5)),
  ramalan = c(dmaramal, f[-1])
)
datagab

ts.plot(datagab[, 1], xlab = "Periode Waktu", ylab = "PDB($)", 
        main = "DMA n=3 Data PDB", ylim = c(min(datagab, na.rm = TRUE), max(datagab, na.rm = TRUE)))

lines(datagab[, 3], col = "blue", lwd = 2)  
lines(datagab[, 6], col = "red", lwd = 2)   
points(datagab[, 1], col = "black", pch = 21, bg = NA)  
points(datagab[, 3], col = "black", pch = 21, bg = NA)   
points(datagab[, 6], col = "black", pch = 21, bg = NA)    

legend("topleft", c("data aktual", "data pemulusan", "data peramalan"),
       col = c("black", "blue", "red"), lty = c(1, 1, 1), lwd = 2, pch = 21, pt.bg = NA, cex = 0.7)


```

## Menghitung akurasi DMA

```{r}
error.dma = DataW2ts-dmaramal[1:length(DataW2ts)]
SSE.dma = sum(error.dma[6:length(DataW2ts)]^2)
MSE.dma = mean(error.dma[6:length(DataW2ts)]^2)
MAPE.dma = mean(abs((error.dma[6:length(DataW2ts)]/DataW2ts[6:length(DataW2ts)])*100))

akurasi.dma <- matrix(c(SSE.dma, MSE.dma, MAPE.dma))
row.names(akurasi.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi.dma) <- c("Akurasi m = 3")
akurasi.dma
```

# Peramalan menggunakan DES

## Pembagian data latih dan uji untuk metode DES

```{r}
DataW2ts.lat <- unlist(DataW2[1:50,2])
DataW2ts.uji <- unlist(DataW2[51:63,2])

latw2ts<-ts(DataW2ts.lat)
uji2w2ts<-ts(DataW2ts.uji,start=51)

plot(DataW2ts,ylab="PDB($)", col="red",main="Plot semua data")
points(DataW2ts)

plot(DataW2ts.lat,ylab="PDB($)", main = "Plot data latih", type = "p")
points(DataW2ts.lat, col="black")
lines(DataW2ts.lat,col="blue")

```

## Pemulusan DES

```{r}
desopt<- HoltWinters(DataW2ts.lat, gamma = FALSE)
desopt
plot(desopt)
legend("topleft", c("Data Aktual", "Peramalan"), col = c("black", "red"), 
       lty = c(1,1))

ramaldesopt<- forecast(desopt, h=13)
ramaldesopt
```

## Akurasi DES data latih

```{r}
ssedes.train<-desopt$SSE
msedes.train<-ssedes.train/length(latw2ts)
sisaandes<-ramaldesopt$residuals
head(sisaandes)

mapedes.train <- sum(abs(sisaandes[3:length(latw2ts)]/latw2ts[3:length(latw2ts)])*100)/length(latw2ts)

akurasides.opt <- matrix(c(ssedes.train,msedes.train,mapedes.train))
row.names(akurasides.opt)<- c("SSE", "MSE", "MAPE")
colnames(akurasides.opt) <- c("Akurasi lamda dan gamma optimum")
akurasides.opt
```

## Akurasi DES data uji

```{r}
selisihdesopt<-ramaldesopt$mean-uji2w2ts


SSEtestingdesopt<-sum(selisihdesopt^2)
SSEtestingdesopt<-SSEtestingdesopt/length(uji2w2ts)
MAPEtestingdesopt<-sum(abs(selisihdesopt/uji2w2ts)*100)/length(uji2w2ts)

akurasiDesTesting <- matrix(c(SSEtestingdesopt,SSEtestingdesopt,MAPEtestingdesopt))
row.names(akurasiDesTesting)<- c("SSE", "MSE", "MAPE")
colnames(akurasiDesTesting) <- c("Akurasi lamda dan gamma optimum")
akurasiDesTesting
```

## Perbandingan akurasi DMA dengan DES

```{r}
cbind(akurasi.dma, akurasides.opt)
```

Pemulusan dilakukan pada data PDB negara Bermuda dari rentang tahun 1960-2022(full). Berdasarkan nilai akurasi SSE, MSE, dan MAPE, metode DES memiliki nilai-nilai akurasi yang lebih kecil daripada metode DMA. Hal ini membuat metode DES lebih baik daripada metode DMA.

# Eksplorasi Data
```{r}
plot(DataW2, pch = 20, col = "blue",
     main = "Scatter Plot Tahun vs PDB($)",
     xlab = "Tahun",
     ylab = "Nilai PDB($)")
#Menampilkan Nilai Korelasi
cor(Tahun,DataW2$PDB)
```
Berdasarkan plot antara tahun dengan nilai pdb, dapat kita lihat bahwa terdapat hubungan positif yang sangat erat. Hal ini juga diperkuat melalui perhitungan korelasi antara peubah tahun dengan nilai pdb, dengan nilai korelasi sebesar *0.9474186*. Nilai ini menunjukkan hubungan positif yang sangat erat.

# Model regresi

```{r}
modelreg<- lm(PDB~Tahun, data = DataW2)
summary(modelreg)
```

Model yang dihasilkan adalah $$y_i=-278030155234 + 141066240 x_t$$. Dari hasil ringkasan model, uji F model memiliki *p-value* \< $\alpha$ (5%), artinya, terdapat minimal satu variabel yang berpengaruh signifikan terhadap model. Hasil uji-t parsial kedua parameter regresi, yaitu intersep dan koefisien regresi juga menunjukkan hal yang sama, yaitu memiliki *p-value* \< $\alpha$ (5%) sehingga nyata dalam taraf 5%. Selanjutnya dapat dilihat juga nilai $R^2=0.8976$. Artinya, sebesar 89.76% keragaman nilai PDB dapat dijelaskan oleh peubah tahun. Selanjutnya akan dilakukan pengujian terhadap sisaan.

## Pengujian sisaan model

```{r}
sisaan<- residuals(modelreg)
fitValue<- predict(modelreg)

par(mfrow = c(2,2))
qqnorm(sisaan)
qqline(sisaan, col = "steelblue", lwd = 2)
plot(fitValue, sisaan, col = "steelblue", pch = 20, xlab = "Sisaan", ylab = "Fitted Values", main = "Sisaan vs Fitted Values")
abline(a = 0, b = 0, lwd = 2)
hist(sisaan, col = "steelblue")
plot(seq(1,63,1), sisaan, col = "steelblue", pch = 20, xlab = "Sisaan", ylab = "Order", main = "Sisaan vs Order")
lines(seq(1,63,1), sisaan, col = "red")
abline(a = 0, b = 0, lwd = 2)
```
Normal QQ plot di atas menunjukkan bahwa sisaan cenderung menyebar normal, begitu juga dengan histogram sisaan. Plot Sisaan vs *Fitted Value* dan Plot Sisaan vs *Order* menunjukkan adanya pola pada sisaan. Selanjtnya akan dilakukan pengujian formal untum melihat normalitas sisaan dan plot ACF serta PACF untuk melihat apakah terdapat autokorelasi atau tidak.

## Uji formal

### Uji normalitas

```{r}
shapiro.test(sisaan)
ks.test(sisaan, "pnorm", mean=mean(sisaan), sd=sd(sisaan))
```

H0: sisaan mengikuti sebaran normal,
H1: sisaan tidak mengikuti sebaran normal.

Berdasarkan uji normalitas *Kolmogorov Smirnov*, diperoleh nilai p uji *Kolmogorov Smirnov* sebesar 0.3901, yang mana lebih besar daripada $\alpha= 5$%, sehingga kesimpulan yang didapat adalah tak tolak H0, artinya sisaan mengikuti sebaran normal

### Uji ACF dan PACF
```{r}
par(mfrow = c(1,2))
acf(sisaan)
pacf(sisaan)
```

Pada plot ACF, terdapat lag yang melebihi batas, yakni lag ke 1 sampai 9. Pada plot PACF tidak terdapat lag yang signifikan. Namun, untuk lebih memastikan akan dilakukan uji formal dengan uji Durbin Watson.

### Uji Durbin Watson

```{r}
dwtest(modelreg)
```
H0: tidak ada autokorelasi,
H1: ada autokorelasi.

Berdasarkan uji Durbin Watson yang telah dilakukan, diperoleh nilai p sebesar 2.2e-16 < $\alpha=5$%. Kesimpulan yang dapat diambil adalah pada taraf nyata 5%, tolak H0, artinya terdapat autokorelasi, sehingga diperlukan penanganan untuk autokorelasi tersebut. Penanganan autokorelasi yang akan dilakukan adalah metode Cochrane-Orcutt dan Hildret-Lu.

# Penanganan Autokorelasi

## Metode Cochrane-Orcutt

```{r}
modelCO<-cochrane.orcutt(modelreg)
modelCO
rho<-modelCO$rho
```
Model yang didapat dari metode Cochrane-Orcutt adalah $$y_i=-395823454080 + 199612066 x_t$$. Metode Cocharane-Orcutt juga menunjukkan bahwa nilai DW dan p-value meningkat menjadi $1.27215$ dan $0.0009071$. Namun nilai DW tidak berada pada rentang DU \< DW \< 4-DU, melainkan masih berada dalam rentang DW<DL atau $1.27215<1.5599$. Nilai p juga masih lebih kecil daripada taraf nyata $\alpha=5$%. Artinya, masih tolak H0, yang mana masih terdapat autokorelasi pada taraf nyata 5%.

### Transformasi data

```{r}
PDB
PDB[-1]
```

```{r}
PDBtrans<- PDB[-1]-PDB[-63]*rho
Tahuntrans<- Tahun[-1]-Tahun[-63]*rho
modelCOmanual<- lm(PDBtrans~Tahuntrans)
summary(modelCOmanual)
```

Hasil transformasi ini bukanlah merupakan model sesungguhnya. Koefisien regresi masih perlu dicari kembali mengikuti $\beta_0^*=\beta_0+ \rho \beta_0$ dan $\beta_1^*=\beta_1$.

```{r}
b0bintang <- modelCOmanual$coefficients[-2]
b0 <- b0bintang/(1-rho)
b1 <- modelCOmanual$coefficients[-1]
b0
b1
```
Hasil $\beta_0$dan$\beta_1$ sudah sama dengan jika menggunakan fungsi cochrane.orcutt(modelreg).

## Metode Hildreth-Lu

```{r}
HiLu.func<- function(r, modelreg){
  x <- model.matrix(modelreg)[,-1]
  y <- model.response(model.frame(modelreg))
  n <- length(y)
  t <- 2:n
  y <- y[t]-r*y[t-1]
  x <- x[t]-r*x[t-1]
  
  return(lm(y~x))
}

r <- c(seq(0.1,1, by= 0.1))
tab <- data.frame("rho" = r, "SSE" = sapply(r, function(i){deviance(HiLu.func(i, modelreg))}))
round(tab, 4)
```

Pada $\rho=0.9$, didapatkan nilai SSE yang paling minimum. Selanjutnya akan dilakukan pencarian nilai $\rho$ dengan jarak yang lebih kecil yang dapat lebih meminimumkan nilai SSE. Pencarian nilai $\rho$ yang diduga lebih meminumkan SSE akan dilakukan dalam selang 0.9 sampai 1 dengan jarak 0.001

```{r}
rOpt <- seq(0.9,1.5, by= 0.001)
tabOpt <- data.frame("rho" = rOpt, "SSE" = sapply(rOpt, function(i){deviance(HiLu.func(i, modelreg))}))
head(tabOpt[order(tabOpt$SSE),])

#Grafik SSE optimum
par(mfrow = c(1,1))
plot(tab$SSE ~ tab$rho , type = "l", xlab = "Rho", ylab = "SSE")
abline(v = tabOpt[tabOpt$SSE==min(tabOpt$SSE),"rho"], lty = 2, col="red",lwd=2)
text(x=0.940121, y=4800000000000000000, labels = "rho=0.940121", cex = 0.8)
```

Perhitungan yang dilakukan aplikasi `R` menunjukkan bahwa nilai $\rho$ optimum, yaitu saat SSE terkecil terdapat pada nilai $\rho=0.9401$. 

```{r}
modelHiLu <- HiLu.func(0.9401, modelreg)
summary(modelHiLu)

#Transformasi Balik
cat("y = ", coef(modelHiLu)[1]/(1-0.9401), "+", coef(modelHiLu)[2],"x", sep = "")
```

Setelah melakukan transformasi balik, didapatkan model dengan metode Hildreth-Lu : $$y_i=-395780908856+199591088x_t$$

### Uji Durbin-Watson model Hildreth-Lu

```{r}
dwtest(modelHiLu)
```

Hasil uji Durbin-Watson juga menunjukkan bawah nilai DW sebesar $1.2721$ berada pada selang daerah yang ada autokorelasi, yaitu pada rentang DW<DL atau $1.27215<1.5599$. Hal tersebut juga didukung oleh *p-value* sebesar $0.0009068$, di mana *p-value* \< $\alpha=5$%. Artinya tolak $H_0$, terdapat cukup bukti untuk menyatakan bahwa ada autokorelasi dalam data nilai PDB dengan metode Hildreth-Lu pada taraf nyata 5%.

# Perbandingan SSE model awal, model Cochrane-Orcutt, dan model Hildreth-Lu

```{r}
#Perbandingan
sseModelawal <- anova(modelreg)$`Sum Sq`[-1]
sseModelCO <- anova(modelCOmanual)$`Sum Sq`[-1]
sseModelHL <- anova(modelHiLu)$`Sum Sq`[-1]
mseModelawal <- sseModelawal/length(PDB)
mseModelCO <- sseModelCO/length(PDB)
mseModelHL <- sseModelHL/length(PDB)
akurasi <- matrix(c(sseModelawal,sseModelCO,sseModelHL,
                    mseModelawal,mseModelCO,mseModelHL),nrow=2,ncol=3,byrow = T)
colnames(akurasi) <- c("Model Awal", "Model Cochrane-Orcutt", "Model Hildreth-Lu")
row.names(akurasi) <- c("SSE","MSE")
akurasi
```
Dari akurasi SSE pada semua model, model Cochrane-Orcutt dan model Hildreth-Lu memiliki nilai SSE dan MSE yang sama persis, dan sama-sama lebih kecil daripada model awal. Hal ini menunjukkan bahwa model Cochrane-Orcutt dan model Hildreth-Lu lebih baik daripada model awal.

# Kesimpulan
Penanganan autokorelasi pada data awal(rentang tahun 1960-2022). Penanganan dilakukan dengan metode Cochrane-Orcutt dan Hildreth-Lu. Model Cochrane-Orcutt dan model Hildreth-Lu memiliki nilai SSE dan MSE yang lebih kecil daripada model awal. Akan tetapi kedua metode masih belum bisa menangani autokorelasi pada data PDB negara Bermuda. Perlu dilakukan metode lain untuk menangani autokorelasi pada data PDB negara Bermuda.
